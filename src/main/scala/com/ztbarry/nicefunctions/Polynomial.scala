package com.ztbarry.nicefunctions
import scala.math.pow
import scala.math.max
// https://docs.scala-lang.org/getting-started/intellij-track/testing-scala-in-intellij-with-scalatest.html
// 
/** Representation of a polynomial function.
 *
 * @constructor create a new polynomial with coefficients
 * @param coef the coefficients, in increasing order from the value
 *        of the constant term
 *
 * To represent 4 + 2 * x`^`2, pass coef = Vector(4, 0, 1). If
 * Vector(4, 1) is passed, the function is interpreted as 4 + x.
 */
class Polynomial(coef: Vector[Double]) {

  require(coef.nonEmpty)

  /** Alternate constructors */
  def this(coef: Array[Double]) = this(coef.toVector)
  def this(coef: Double) = this(Vector[Double](coef))

  /** Returns the coefficients */
  def coef(): Vector[Double] = coef

  /** Returns written form of polynomial (e.g. "2 + 3x + 5x`^`2") */
  override def toString: String = {
    coef
      .zipWithIndex
      .map({ case(c, p) => s"${c}x^$p"})
      .mkString(" + ")
  }

  /** Returns the polynomial function */
  val fun = (x: Double) => {
    coef
      .zipWithIndex
      .map({ case(c, p) => c * pow(x, p) })
      .sum
  }

  /** Returns value of polynomial for an input */
  def eval(x: Double): Double = {
    fun(x)
  }

  /** Returns values of polynomial for a number of inputs */
  def eval(x: Vector[Double]): Vector[Double] = {
    x map eval
  }

  /** Returns a new polynomial with coefficients multiplied by the
   *  argument.
   */
  def * (n: Double): Polynomial = {
    new Polynomial(coef.map(_ * n))
  }

  /** Returns a new polynomial with coefficients divided by the
   *  argument.  Uses Option to handle n = 0.
   */
  def / (n: Double): Option[Polynomial] = {
    if (n == 0.0) {
      None
    } else {
      Some(new Polynomial(coef.map(_ / n)))
    }
  }

  /** Returns a new polynomial generated by adding the coefficients
   *  from a passed polynomial to this coefficients.
   */
  def + (that: Polynomial): Polynomial = {
    val length = max(this.coef.length, that.coef.length)

    val newCoef = for (i <- Vector.range(0, length)) yield {
      this.coef.lift(i).getOrElse(0.0) + that.coef.lift(i).getOrElse(0.0)
    }

    new Polynomial(newCoef)
  }

  /** Returns a new polynomial generated by subtracting the coefficients
   * from a passed polynomial from this coefficients. */
  def - (that: Polynomial): Polynomial = {
    this + (that * -1)
  }

}
